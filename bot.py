import logging
import os
import threading
import time
import requests
import asyncio
import random
import json
from datetime import datetime, date, timedelta
import pytz
from flask import Flask
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, JobQueue
from telegram.error import TelegramError, BadRequest, Conflict
from locales import TEXTS, ZODIAC_SIGNS, ZODIAC_CALLBACK_MAP

# --- Helper Functions ---

def get_text(key: str, lang: str) -> str:
    """Retrieves a text string in the specified language."""
    return TEXTS.get(key, {}).get(lang, TEXTS.get(key, {}).get("ru", key))

def get_user_lang(chat_id: int) -> str:
    """Gets the user's selected language, defaulting to Russian."""
    return get_user_data(chat_id).get("language", "ru")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

BOT_TOKEN = os.environ.get('BOT_TOKEN', '')

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç (–º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏)
CRYPTO_APIS = {
    "coingecko": {
        "url": "https://api.coingecko.com/api/v3/simple/price",
        "params": {
            "ids": "bitcoin,ethereum,the-open-network",
            "vs_currencies": "usd",
            "include_24hr_change": "true"
        },
        "headers": {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        }
    },
    "binance": {
        "url": "https://api.binance.com/api/v3/ticker/24hr",
        "symbols": ["BTCUSDT", "ETHUSDT", "TONUSDT"]
    },
    "cryptocompare": {
        "url": "https://min-api.cryptocompare.com/data/pricemultifull",
        "params": {
            "fsyms": "BTC,ETH,TON",
            "tsyms": "USD"
        }
    }
}

CRYPTO_IDS = {
    "btc": "bitcoin",
    "eth": "ethereum", 
    "ton": "the-open-network"
}

# –•—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
user_data = {}

# –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
crypto_prices = {
    "btc": {"price": None, "change": None, "last_update": None, "source": None},
    "eth": {"price": None, "change": None, "last_update": None, "source": None},
    "ton": {"price": None, "change": None, "last_update": None, "source": None}
}

# –ö—ç—à –¥–ª—è API –∑–∞–ø—Ä–æ—Å–æ–≤
api_cache = {
    "last_update": None,
    "cache_duration": 300,  # 5 –º–∏–Ω—É—Ç
    "failed_attempts": 0,
    "current_source": "coingecko"
}

def save_cache_to_file():
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫—ç—à–∞ –≤ —Ñ–∞–π–ª"""
    try:
        cache_data = {
            "crypto_prices": crypto_prices,
            "api_cache": api_cache,
            "timestamp": datetime.now().isoformat()
        }
        with open("cache.json", "w") as f:
            json.dump(cache_data, f, default=str)
        logger.info("üíæ –ö—ç—à —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–∞–π–ª")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫—ç—à–∞: {e}")

def load_cache_from_file():
    """–ó–∞–≥—Ä—É–∑–∫–∞ –∫—ç—à–∞ –∏–∑ —Ñ–∞–π–ª–∞"""
    try:
        with open("cache.json", "r") as f:
            cache_data = json.load(f)
        
        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        global crypto_prices, api_cache
        crypto_prices = cache_data.get("crypto_prices", crypto_prices)
        api_cache = cache_data.get("api_cache", api_cache)
        
        logger.info("üìÇ –ö—ç—à –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ —Ñ–∞–π–ª–∞")
        return True
    except FileNotFoundError:
        logger.info("üìÇ –§–∞–π–ª –∫—ç—à–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
        return False
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫—ç—à–∞: {e}")
        return False

# –†–µ–∑–µ—Ä–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–ª—É—á–∞–π –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ API
FALLBACK_DATA = {
    "btc": {"price": 60000, "change": 1.2, "source": "fallback"},
    "eth": {"price": 3000, "change": 0.8, "source": "fallback"},
    "ton": {"price": 7.50, "change": 2.5, "source": "fallback"}
}

def generate_bilingual_horoscopes():
    """Generates a database of horoscopes in both Russian and English."""
    themes = [
        {"ru": "–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏", "en": "investments"}, {"ru": "—Ç—Ä–µ–π–¥–∏–Ω–≥", "en": "trading"},
        {"ru": "—Å—Ç–µ–π–∫–∏–Ω–≥", "en": "staking"}, {"ru": "NFT", "en": "NFTs"},
        {"ru": "DeFi", "en": "DeFi"}, {"ru": "–º–∞–π–Ω–∏–Ω–≥", "en": "mining"}
    ]
    actions = [
        {"ru": "–∏–Ω–≤–µ—Å—Ç–∏—Ä—É–π—Ç–µ –≤", "en": "invest in"}, {"ru": "–∏–∑–±–µ–≥–∞–π—Ç–µ", "en": "avoid"},
        {"ru": "–∏–∑—É—á–∏—Ç–µ", "en": "study"}, {"ru": "–ø—Ä–æ–¥–∞–≤–∞–π—Ç–µ", "en": "sell"},
        {"ru": "–ø–æ–∫—É–ø–∞–π—Ç–µ", "en": "buy"}, {"ru": "—Ö–æ–ª–¥–∏—Ç–µ", "en": "HODL"}
    ]
    assets = [
        "BTC", "TON", "ETH", "SOL", "DOGE", "memecoins", "altcoins", "blue chips",
        "new projects", "infrastructure tokens", "L2 solutions"
    ]
    moods = [
        {"ru": "—É–¥–∞—á–Ω—ã–π –¥–µ–Ω—å", "en": "a lucky day"}, {"ru": "–æ—Å—Ç–æ—Ä–æ–∂–Ω—ã–π –¥–µ–Ω—å", "en": "a cautious day"},
        {"ru": "—Ä–∏—Å–∫–æ–≤–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥", "en": "a risky period"}, {"ru": "–≤—Ä–µ–º—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π", "en": "a time of opportunity"}
    ]
    endings = [
        {"ru": "—É–¥–∞—á–∞ –Ω–∞ –≤–∞—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ", "en": "luck is on your side"},
        {"ru": "–±—É–¥—å—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã –∫ –¥–µ—Ç–∞–ª—è–º", "en": "be attentive to details"},
        {"ru": "–¥–æ–≤–µ—Ä—è–π—Ç–µ –∏–Ω—Ç—É–∏—Ü–∏–∏", "en": "trust your intuition"},
        {"ru": "–ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é", "en": "verify information"}
    ]

    horoscopes = {"ru": {}, "en": {}}
    zodiac_pairs = zip(ZODIAC_SIGNS["ru"], ZODIAC_SIGNS["en"])

    for sign_ru, sign_en in zodiac_pairs:
        variants_ru, variants_en = [], []
        for _ in range(30):  # 30 variants for each sign
            theme, action, mood, ending = random.choice(themes), random.choice(actions), random.choice(moods), random.choice(endings)
            asset = random.choice(assets)
            emoji = random.choice(["üöÄ", "üíé", "üîÆ", "üåü", "‚ú®", "üåï", "üî•", "üí°", "‚ö°"])

            text_ru = (
                f"{emoji} *{sign_ru}:*\n"
                f"–°–µ–≥–æ–¥–Ω—è *{mood['ru']}* –¥–ª—è –∫—Ä–∏–ø—Ç–æ-–∞–∫—Ç–∏–≤–æ–≤! –ó–≤–µ–∑–¥—ã —Å–æ–≤–µ—Ç—É—é—Ç: "
                f"*{action['ru']} {asset}.*\n"
                f"–û—Å–æ–±–æ–µ –≤–Ω–∏–º–∞–Ω–∏–µ —É–¥–µ–ª–∏—Ç–µ *{theme['ru']}*. {ending['ru'].capitalize()}!"
            )
            text_en = (
                f"{emoji} *{sign_en}:*\n"
                f"Today is *{mood['en']}* for crypto assets! The stars advise: "
                f"*{action['en']} {asset}.*\n"
                f"Pay special attention to *{theme['en']}*. {ending['en'].capitalize()}!"
            )
            variants_ru.append(text_ru)
            variants_en.append(text_en)

        horoscopes["ru"][sign_ru] = variants_ru
        horoscopes["en"][sign_en] = variants_en

    return horoscopes

HOROSCOPES_DB = generate_bilingual_horoscopes()

PREMIUM_OPTIONS = {
    "tomorrow": {
        "title": {"ru": "üîÆ –ó–∞–≤—Ç—Ä–∞—à–Ω–∏–π –ø—Ä–æ–≥–Ω–æ–∑", "en": "üîÆ Tomorrow's Forecast"},
        "description": {"ru": "–£–∑–Ω–∞–π—Ç–µ, —á—Ç–æ –∂–¥–µ—Ç –≤–∞—à –ø–æ—Ä—Ç—Ñ–µ–ª—å –∑–∞–≤—Ç—Ä–∞", "en": "Find out what awaits your portfolio tomorrow"},
        "price": "2$"
    },
    "weekly": {
        "title": {"ru": "üìÖ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –Ω–µ–¥–µ–ª—é", "en": "üìÖ Weekly Forecast"},
        "description": {"ru": "–ü–ª–∞–Ω–∏—Ä—É–π—Ç–µ —Å–≤–æ—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –Ω–∞ –≤—Å—é –Ω–µ–¥–µ–ª—é", "en": "Plan your strategy for the whole week"},
        "price": "5$"
    },
    "permanent": {
        "title": {"ru": "üíé –ü–æ—Å—Ç–æ—è–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø", "en": "üíé Permanent Access"},
        "description": {"ru": "–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –ø—Ä–æ–≥–Ω–æ–∑—ã –∏ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–µ –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã", "en": "Daily forecasts and exclusive analytical materials"},
        "price": "7$/–º–µ—Å"
    }
}


def get_user_data(chat_id: int) -> dict:
    """Gets or creates a user's data entry."""
    if chat_id not in user_data:
        user_data[chat_id] = {
            "language": None,
            "notifications": True,
            "last_update": None,
            "tip_index": None,
            "horoscope_indices": {}
        }
    return user_data[chat_id]

def update_user_horoscope(chat_id: int):
    """
    Checks if the user's daily content is outdated and regenerates it if necessary.
    This function ensures that a user gets a new random tip and set of horoscopes once per day.
    It stores indices to ensure content is consistent across language changes.
    """
    user_info = get_user_data(chat_id)
    today = date.today()

    if user_info.get("last_update") != today:
        logger.info(f"Updating daily content for user {chat_id}")
        user_info["last_update"] = today

        # Select a random index for the learning tip
        num_tips = len(TEXTS["learning_tips"]["ru"])  # Both languages have the same number of tips
        user_info["tip_index"] = random.randint(0, num_tips - 1)

        # Select random indices for each zodiac sign's horoscope
        horoscope_indices = {}
        for sign_ru in ZODIAC_SIGNS["ru"]:
            num_variants = len(HOROSCOPES_DB["ru"][sign_ru])
            horoscope_indices[sign_ru] = random.randint(0, num_variants - 1)
        user_info["horoscope_indices"] = horoscope_indices

        logger.info(f"Content indices updated for user {chat_id} for {today}")

def update_crypto_prices():
    """–û–±–Ω–æ–≤–ª—è–µ—Ç –∫—É—Ä—Å—ã –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º–∏"""
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–ª—è—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ API
        if api_cache["last_update"] is not None and \
           (datetime.now() - api_cache["last_update"]).total_seconds() < api_cache["cache_duration"]:
            logger.info("–ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫—É—Ä—Å–æ–≤.")
            return

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â–∏–π –∏—Å—Ç–æ—á–Ω–∏–∫ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        current_source = api_cache["current_source"]
        
        if current_source == "coingecko":
            success = _update_from_coingecko()
        elif current_source == "binance":
            success = _update_from_binance()
        elif current_source == "cryptocompare":
            success = _update_from_cryptocompare()
        else:
            logger.warning(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ API: {current_source}. –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.")
            return

        if success:
            api_cache["last_update"] = datetime.now()
            api_cache["failed_attempts"] = 0
            logger.info(f"–ö—É—Ä—Å—ã —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –æ—Ç {current_source}")
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫—ç—à –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            save_cache_to_file()
        else:
            api_cache["failed_attempts"] += 1
            if api_cache["failed_attempts"] >= 3:
                logger.error("–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –Ω–µ—É–¥–∞—á–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤. –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.")
                _use_fallback_data()
                save_cache_to_file()
            else:
                # –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –∏—Å—Ç–æ—á–Ω–∏–∫
                _switch_api_source()
                logger.info(f"–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ –∏—Å—Ç–æ—á–Ω–∏–∫: {api_cache['current_source']}")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤: {e}")
        _use_fallback_data()

def _update_from_coingecko():
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ –æ—Ç CoinGecko API"""
    try:
        api_config = CRYPTO_APIS["coingecko"]
        response = requests.get(
            api_config["url"], 
            params=api_config["params"], 
            headers=api_config["headers"], 
            timeout=15
        )
        
        if response.status_code == 429:
            logger.warning("CoinGecko: –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤")
            return False
            
        response.raise_for_status()
        prices = response.json()
        
        current_time = datetime.now()
        success_count = 0
        
        for symbol, coin_id in CRYPTO_IDS.items():
            if coin_id in prices:
                coin_data = prices[coin_id]
                price = coin_data.get("usd")
                change = coin_data.get("usd_24h_change")
                
                if price is not None and change is not None:
                    crypto_prices[symbol]["price"] = price
                    crypto_prices[symbol]["change"] = change
                    crypto_prices[symbol]["last_update"] = current_time
                    crypto_prices[symbol]["source"] = "coingecko"
                    success_count += 1
                    logger.info(f"–ö—É—Ä—Å {symbol.upper()}: ${price:.2f} ({change:.2f}%)")
        
        return success_count > 0
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ CoinGecko API: {e}")
        return False

def _update_from_binance():
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ –æ—Ç Binance API"""
    try:
        api_config = CRYPTO_APIS["binance"]
        current_time = datetime.now()
        success_count = 0
        
        for symbol in api_config["symbols"]:
            response = requests.get(
                f"{api_config['url']}?symbol={symbol}",
                timeout=10
            )
            
            if response.status_code == 429:
                logger.warning("Binance: –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤")
                return False
                
            response.raise_for_status()
            data = response.json()
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–∏–º–≤–æ–ª—ã Binance –≤ –Ω–∞—à–∏ —Å–∏–º–≤–æ–ª—ã
            symbol_map = {"BTCUSDT": "btc", "ETHUSDT": "eth", "TONUSDT": "ton"}
            our_symbol = symbol_map.get(symbol)
            
            if our_symbol and data:
                price = float(data.get("lastPrice", 0))
                change = float(data.get("priceChangePercent", 0))
                
                if price > 0:
                    crypto_prices[our_symbol]["price"] = price
                    crypto_prices[our_symbol]["change"] = change
                    crypto_prices[our_symbol]["last_update"] = current_time
                    crypto_prices[our_symbol]["source"] = "binance"
                    success_count += 1
                    logger.info(f"–ö—É—Ä—Å {our_symbol.upper()}: ${price:.2f} ({change:.2f}%)")
        
        return success_count > 0
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ Binance API: {e}")
        return False

def _update_from_cryptocompare():
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ –æ—Ç CryptoCompare API"""
    try:
        api_config = CRYPTO_APIS["cryptocompare"]
        response = requests.get(
            api_config["url"],
            params=api_config["params"],
            timeout=15
        )
        
        if response.status_code == 429:
            logger.warning("CryptoCompare: –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤")
            return False
            
        response.raise_for_status()
        data = response.json()
        
        current_time = datetime.now()
        success_count = 0
        
        if "RAW" in data:
            raw_data = data["RAW"]
            symbol_map = {"BTC": "btc", "ETH": "eth", "TON": "ton"}
            
            for api_symbol, our_symbol in symbol_map.items():
                if api_symbol in raw_data and "USD" in raw_data[api_symbol]:
                    usd_data = raw_data[api_symbol]["USD"]
                    price = usd_data.get("PRICE", 0)
                    change = usd_data.get("CHANGEPCT24HOUR", 0)
                    
                    if price > 0:
                        crypto_prices[our_symbol]["price"] = price
                        crypto_prices[our_symbol]["change"] = change
                        crypto_prices[our_symbol]["last_update"] = current_time
                        crypto_prices[our_symbol]["source"] = "cryptocompare"
                        success_count += 1
                        logger.info(f"–ö—É—Ä—Å {our_symbol.upper()}: ${price:.2f} ({change:.2f}%)")
        
        return success_count > 0
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ CryptoCompare API: {e}")
        return False

def _switch_api_source():
    """–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –º–µ–∂–¥—É –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º–∏ API"""
    sources = ["coingecko", "binance", "cryptocompare"]
    current = api_cache["current_source"]
    
    try:
        current_index = sources.index(current)
        next_index = (current_index + 1) % len(sources)
        api_cache["current_source"] = sources[next_index]
    except ValueError:
        api_cache["current_source"] = "coingecko"

def _use_fallback_data():
    """–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
    current_time = datetime.now()
    for symbol, data in FALLBACK_DATA.items():
        crypto_prices[symbol]["price"] = data["price"]
        crypto_prices[symbol]["change"] = data["change"]
        crypto_prices[symbol]["last_update"] = current_time
        crypto_prices[symbol]["source"] = data["source"]
    logger.info("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã —Ä–µ–∑–µ—Ä–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫—É—Ä—Å–æ–≤")

def format_change_bar(percent_change):
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã"""
    if percent_change is None:
        return "N/A", ""
    
    bar_length = 10
    filled = min(int(abs(percent_change) * bar_length / 10), bar_length)
    bar = "‚ñ∞" * filled + "‚ñ±" * (bar_length - filled)
    symbol = "‚ñ≤" if percent_change >= 0 else "‚ñº"
    color = "üü¢" if percent_change >= 0 else "üî¥"
    return f"{color} {symbol}{abs(percent_change):.1f}%", bar

def main_menu_keyboard(lang: str):
    """Creates the main menu keyboard in the specified language."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton(get_text("horoscope_button", lang), callback_data="horoscope_menu")
        ],
        [
            InlineKeyboardButton(get_text("tip_button", lang), callback_data="learning_tip"),
            InlineKeyboardButton(get_text("settings_button", lang), callback_data="settings_menu")
        ],
        [
            InlineKeyboardButton(get_text("premium_button", lang), callback_data="premium_menu")
        ]
    ])

def back_to_menu_keyboard(lang: str):
    """Creates a back button in the specified language."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(get_text("back_button", lang), callback_data="main_menu")]
    ])

def zodiac_keyboard(lang: str):
    """Creates the zodiac selection keyboard in the specified language."""
    zodiacs = ZODIAC_SIGNS[lang]
    original_zodiacs = ZODIAC_SIGNS["ru"] # Callbacks use Russian names
    buttons = []
    
    # Create rows of 3 buttons
    for i in range(0, len(zodiacs), 3):
        row = zodiacs[i:i+3]
        original_row = original_zodiacs[i:i+3]
        buttons.append([
            InlineKeyboardButton(zod, callback_data=f"zodiac_{orig_zod}")
            for zod, orig_zod in zip(row, original_row)
        ])
    
    # Add back button
    buttons.append([InlineKeyboardButton(get_text("back_button", lang), callback_data="main_menu")])
    
    return InlineKeyboardMarkup(buttons)

def settings_keyboard(chat_id: int, lang: str):
    """Creates the settings keyboard in the specified language."""
    user_info = get_user_data(chat_id)
    notifications_on = user_info.get("notifications", True)
    
    toggle_key = "toggle_notifications_off_button" if notifications_on else "toggle_notifications_on_button"
    toggle_text = get_text(toggle_key, lang)
    
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(toggle_text, callback_data="toggle_notifications")],
        [InlineKeyboardButton(get_text("change_language_button", lang), callback_data="change_language")],
        [InlineKeyboardButton(get_text("back_button", lang), callback_data="main_menu")]
    ])

def premium_menu_keyboard(lang: str):
    """Creates the premium menu keyboard in the specified language."""
    buttons = [
        [InlineKeyboardButton(
            f"{opt['title'][lang]} ({opt['price']})",
            callback_data=f"premium_{option}"
        )] for option, opt in PREMIUM_OPTIONS.items()
    ]
    buttons.append([InlineKeyboardButton(get_text("back_button", lang), callback_data="main_menu")])
    return InlineKeyboardMarkup(buttons)

def language_keyboard():
    """Returns the language selection keyboard."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="set_lang_ru"),
            InlineKeyboardButton("üá¨üáß English", callback_data="set_lang_en"),
        ]
    ])

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handler for the /start command."""
    user = update.effective_user
    chat_id = update.effective_chat.id
    user_info = get_user_data(chat_id)

    if user_info.get("language") is None:
        await context.bot.send_message(
            chat_id=chat_id,
            text=get_text("language_select", "ru"),  # Send in both languages initially
            reply_markup=language_keyboard()
        )
        return

    lang = user_info["language"]
    
    # Update user's daily content if needed
    update_user_horoscope(chat_id)

    # Update crypto prices
    update_crypto_prices()
    
    # Welcome message
    welcome_text = get_text("welcome", lang).format(first_name=user.first_name)
    
    await context.bot.send_message(
        chat_id=chat_id,
        text=welcome_text,
        reply_markup=main_menu_keyboard(lang),
        parse_mode="Markdown",
        disable_web_page_preview=True
    )
    
    # Schedule notifications if enabled
    if user_info["notifications"] and context.job_queue:
        schedule_user_notifications(context.job_queue, chat_id)
        logger.info(f"Notifications activated for user {chat_id}")

async def set_language(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Callback handler for language selection."""
    query = update.callback_query
    await query.answer()

    chat_id = query.message.chat_id
    user_info = get_user_data(chat_id)
    lang = query.data.split("_")[-1]  # 'ru' or 'en'
    user_info["language"] = lang

    # Show the main menu in the selected language
    await show_main_menu(update, context)

def schedule_user_notifications(job_queue, chat_id):
    """–ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –µ–∂–µ—á–∞—Å–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        # –£–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∑–∞–¥–∞—á–∏ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
        current_jobs = job_queue.get_jobs_by_name(f"notification_{chat_id}")
        for job in current_jobs:
            job.schedule_removal()
        
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è –∫–∞–∂–¥—ã–π —á–∞—Å
        job_queue.run_repeating(
            send_notification,
            interval=3600,  # 3600 —Å–µ–∫—É–Ω–¥ = 1 —á–∞—Å
            first=1,  # –ó–∞–ø—É—Å—Ç–∏—Ç—å —á–µ—Ä–µ–∑ 1 —Å–µ–∫—É–Ω–¥—É –ø–æ—Å–ª–µ –≤—ã–∑–æ–≤–∞
            chat_id=chat_id,
            name=f"notification_{chat_id}"
        )
        logger.info(f"–ï–∂–µ—á–∞—Å–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω—ã –¥–ª—è {chat_id}")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è {chat_id}: {e}")

async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the main menu."""
    query = update.callback_query
    chat_id = query.message.chat_id if query else update.effective_chat.id
    lang = get_user_lang(chat_id)

    update_user_horoscope(chat_id)
    update_crypto_prices()
    
    text = get_text("main_menu_title", lang)
    
    try:
        if query:
            # Edit the message if it's a callback query
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=query.message.message_id,
                text=text,
                reply_markup=main_menu_keyboard(lang),
                parse_mode="Markdown"
            )
        else:
            # Send a new message if it's a command
            await context.bot.send_message(
                chat_id=chat_id,
                text=text,
                reply_markup=main_menu_keyboard(lang),
                parse_mode="Markdown"
            )
    except BadRequest as e:
        logger.error(f"Error showing main menu: {e}")

async def show_horoscope_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the zodiac sign selection menu."""
    query = update.callback_query
    await query.answer()
    
    chat_id = query.message.chat_id
    lang = get_user_lang(chat_id)

    update_user_horoscope(chat_id)
    
    try:
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=query.message.message_id,
            text=get_text("zodiac_select_title", lang),
            reply_markup=zodiac_keyboard(lang),
            parse_mode="Markdown"
        )
    except BadRequest as e:
        logger.error(f"Error showing horoscope menu: {e}")

async def show_zodiac_horoscope(update: Update, context: ContextTypes.DEFAULT_TYPE, zodiac: str) -> None:
    """Shows the horoscope for the selected zodiac sign."""
    query = update.callback_query
    await query.answer()
    
    chat_id = query.message.chat_id
    lang = get_user_lang(chat_id)
    
    update_crypto_prices()
    
    current_date = datetime.now().strftime("%d.%m.%Y")
    
    # Get market data text
    market_text = get_text("market_rates_title", lang)
    for symbol in CRYPTO_IDS:
        price_data = crypto_prices[symbol]
        if price_data["price"] is not None and price_data["change"] is not None:
            change_text, bar = format_change_bar(price_data["change"])
            last_update = price_data["last_update"].strftime("%H:%M") if price_data["last_update"] else "N/A"
            source = price_data.get("source", "unknown")
            source_emoji = {"coingecko": "ü¶é", "binance": "üìä", "cryptocompare": "üîÑ", "fallback": "üõ°Ô∏è"}.get(source, "‚ùì")
            market_text += f"{symbol.upper()}: ${price_data['price']:,.2f} {change_text} (24h)\n{bar}\n{get_text('updated_at', lang)}: {last_update} {source_emoji}\n\n"

    # Get the translated zodiac sign name for display
    display_zodiac = zodiac if lang == "ru" else ZODIAC_CALLBACK_MAP.get(zodiac, zodiac)

    # Get the horoscope text using the stored index for the user
    user_info = get_user_data(chat_id)
    horoscope_index = user_info["horoscope_indices"].get(zodiac)

    if horoscope_index is not None:
        horoscope_text = HOROSCOPES_DB[lang][display_zodiac][horoscope_index]
    else:
        horoscope_text = get_text('horoscope_unavailable', lang)

    text = (
        f"‚ú® *{display_zodiac} | {current_date}*\n\n"
        f"{horoscope_text}\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"{market_text}"
    )
    
    try:
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=query.message.message_id,
            text=text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton(get_text('main_menu_button', lang), callback_data='main_menu')]]),
            parse_mode="Markdown"
        )
    except BadRequest as e:
        logger.error(f"Error showing zodiac horoscope: {e}")

async def show_learning_tip(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the tip of the day."""
    query = update.callback_query
    await query.answer()
    
    chat_id = query.message.chat_id
    lang = get_user_lang(chat_id)
    
    # Get the tip of the day using the stored index for the user
    user_info = get_user_data(chat_id)
    tip_index = user_info.get("tip_index")

    if tip_index is not None:
        tip_text = TEXTS["learning_tips"][lang][tip_index]
    else:
        tip_text = get_text('horoscope_unavailable', lang) # Re-using a generic error message

    text = f" *{get_text('tip_of_the_day_title', lang)}*\n\nüåü {tip_text}"
    
    try:
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=query.message.message_id,
            text=text,
            reply_markup=back_to_menu_keyboard(lang),
            parse_mode="Markdown"
        )
    except BadRequest as e:
        logger.error(f"Error showing learning tip: {e}")

async def show_settings_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the settings menu."""
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    lang = get_user_lang(chat_id)
    
    user_info = get_user_data(chat_id)
    notifications_on = user_info.get("notifications", True)
    status_key = "notifications_on" if notifications_on else "notifications_off"
    
    text = (
        f" *{get_text('settings_title', lang)}*\n\n"
        f"{get_text('notifications_status_line', lang).format(status=get_text(status_key, lang))}"
    )
    
    try:
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=query.message.message_id,
            text=text,
            reply_markup=settings_keyboard(chat_id, lang),
            parse_mode="Markdown"
        )
    except BadRequest as e:
        logger.error(f"Error showing settings menu: {e}")

async def change_language(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the language selection menu."""
    query = update.callback_query
    await query.answer()

    await context.bot.edit_message_text(
        chat_id=query.message.chat_id,
        message_id=query.message.message_id,
        text=get_text("language_select", "ru"), # Show in both languages
        reply_markup=language_keyboard()
    )

async def toggle_notifications(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"""
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user_info = get_user_data(chat_id)
    new_status = not user_info.get("notifications", True)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    user_info["notifications"] = new_status
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –∏–ª–∏ —É–¥–∞–ª—è–µ–º –∑–∞–¥–∞—á—É
    if new_status and context.job_queue:
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
        schedule_user_notifications(context.job_queue, chat_id)
        logger.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã –¥–ª—è {chat_id}")
    elif not new_status and context.job_queue:
        # –£–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–¥–∞—á—É
        current_jobs = context.job_queue.get_jobs_by_name(f"notification_{chat_id}")
        for job in current_jobs:
            job.schedule_removal()
        logger.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã –¥–ª—è {chat_id}")
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    await show_settings_menu(update, context)

async def send_notification(context: ContextTypes.DEFAULT_TYPE):
    """Sends a notification to a user in their selected language and deletes it after 10 minutes."""
    job = context.job
    chat_id = job.chat_id
    lang = get_user_lang(chat_id)
    
    # Choose a random alert in the user's language
    alert = random.choice(TEXTS["notification_alerts"][lang])
    
    try:
        message = await context.bot.send_message(
            chat_id=chat_id,
            text=alert,
            parse_mode="Markdown"
        )
        
        # Schedule deletion after 10 minutes
        await asyncio.sleep(600)
        await context.bot.delete_message(
            chat_id=chat_id,
            message_id=message.message_id
        )
        logger.info(f"Notification sent and deleted for {chat_id}")
    except Exception as e:
        logger.error(f"Error sending notification: {e}")

async def show_premium_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows the premium menu."""
    query = update.callback_query
    await query.answer()
    
    chat_id = query.message.chat_id
    lang = get_user_lang(chat_id)

    text = (
        f"üíé *{get_text('premium_menu_title', lang)}*\n\n"
        f"{get_text('premium_menu_description', lang)}"
    )
    
    try:
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=query.message.message_id,
            text=text,
            reply_markup=premium_menu_keyboard(lang),
            parse_mode="Markdown"
        )
    except BadRequest as e:
        logger.error(f"Error showing premium menu: {e}")

async def handle_premium_choice(update: Update, context: ContextTypes.DEFAULT_TYPE, option: str) -> None:
    """Handles a premium option selection."""
    query = update.callback_query
    await query.answer()
    
    chat_id = query.message.chat_id
    lang = get_user_lang(chat_id)

    if option not in PREMIUM_OPTIONS:
        return
    
    selected = PREMIUM_OPTIONS[option]
    text = (
        f"‚ú® *{selected['title'][lang]}* ‚ú®\n\n"
        f"üìù {selected['description'][lang]}\n\n"
        f"üíé *–°—Ç–æ–∏–º–æ—Å—Ç—å:* {selected['price']}\n\n"
        f"{get_text('premium_choice_contact', lang)}"
    )
    
    try:
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=query.message.message_id,
            text=text,
            reply_markup=back_to_menu_keyboard(lang),
            parse_mode="Markdown"
        )
    except BadRequest as e:
        logger.error(f"Error handling premium choice: {e}")

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Main callback query handler."""
    query = update.callback_query
    data = query.data
    lang = get_user_lang(query.message.chat_id)
    
    try:
        if data == "main_menu":
            await show_main_menu(update, context)
        elif data == "horoscope_menu":
            await show_horoscope_menu(update, context)
        elif data.startswith("zodiac_"):
            zodiac = data[7:]
            await show_zodiac_horoscope(update, context, zodiac)
        elif data == "learning_tip":
            await show_learning_tip(update, context)
        elif data == "settings_menu":
            await show_settings_menu(update, context)
        elif data == "toggle_notifications":
            await toggle_notifications(update, context)
        elif data == "premium_menu":
            await show_premium_menu(update, context)
        elif data.startswith("premium_"):
            option = data.split("_")[1]
            await handle_premium_choice(update, context, option)
        elif data.startswith("set_lang_"):
            await set_language(update, context)
        elif data == "change_language":
            await change_language(update, context)

    except Exception as e:
        logger.error(f"Error in button handler: {e}")
        await query.answer(get_text("error_occurred", lang))

def run_flask_server():
    """–ó–∞–ø—É—Å–∫ Flask-—Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è Render"""
    app = Flask(__name__)

    @app.route('/')
    def home():
        return "ü§ñ AstroKit Bot is running! UptimeRobot monitoring active."

    @app.route('/health')
    def health_check():
        return "OK", 200

    port = int(os.environ.get("PORT", 10000))
    app.run(host='0.0.0.0', port=port, threaded=True)

def keep_alive():
    """–†–µ–≥—É–ª—è—Ä–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –Ω–∞ Render"""
    while True:
        try:
            # –ü–æ–ª—É—á–∞–µ–º URL —Å–µ—Ä–≤–µ—Ä–∞
            server_url = os.environ.get('RENDER_EXTERNAL_URL', 'http://localhost:10000')
            health_url = f"{server_url}/health"
            
            # –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å —Å —Ç–∞–π–º–∞—É—Ç–æ–º
            response = requests.get(health_url, timeout=15)
            
            if response.status_code == 200:
                logger.info(f"‚úÖ Keep-alive —É—Å–ø–µ—à–µ–Ω: {response.status_code}")
            else:
                logger.warning(f"‚ö†Ô∏è Keep-alive: –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å {response.status_code}")
                
        except requests.exceptions.Timeout:
            logger.warning("‚è∞ Keep-alive: —Ç–∞–π–º–∞—É—Ç –∑–∞–ø—Ä–æ—Å–∞")
        except requests.exceptions.ConnectionError:
            logger.error("üîå Keep-alive: –æ—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è")
        except Exception as e:
            logger.error(f"‚ùå Keep-alive –æ—à–∏–±–∫–∞: {e}")
        
        # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–æ 14 –º–∏–Ω—É—Ç –¥–ª—è Render
        time.sleep(14 * 60)  # 14 –º–∏–Ω—É—Ç

def main() -> None:
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π –¥–ª—è Render"""
    if not BOT_TOKEN:
        logger.error("‚ùå BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
        return

    logger.info("üöÄ –ó–∞–ø—É—Å–∫ AstroKit Bot...")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫—ç—à –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
    logger.info("üìÇ –ó–∞–≥—Ä—É–∑–∫–∞ –∫—ç—à–∞...")
    cache_loaded = load_cache_from_file()
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç
    logger.info("üìä –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç...")
    if not cache_loaded:
        update_crypto_prices()
    else:
        logger.info("‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ")
    
    # –ó–∞–ø—É—Å–∫ Flask —Å–µ—Ä–≤–µ—Ä–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    server_thread = threading.Thread(target=run_flask_server, name="FlaskServer")
    server_thread.daemon = True
    server_thread.start()
    logger.info(f"üåê HTTP —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {os.environ.get('PORT', 10000)}")

    # Keep-alive –¥–ª—è Render (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–∞–ø—É—â–µ–Ω–æ –Ω–∞ Render)
    is_render = os.environ.get('RENDER') or os.environ.get('RENDER_EXTERNAL_URL')
    if is_render:
        wakeup_thread = threading.Thread(target=keep_alive, name="KeepAlive")
        wakeup_thread.daemon = True
        wakeup_thread.start()
        logger.info("üîî Keep-alive –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω (–∏–Ω—Ç–µ—Ä–≤–∞–ª: 14 –º–∏–Ω—É—Ç)")
    else:
        logger.info("üè† –õ–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º - keep-alive –æ—Ç–∫–ª—é—á–µ–Ω")

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ —Å JobQueue
    logger.info("ü§ñ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram –±–æ—Ç–∞...")
    application = Application.builder().token(BOT_TOKEN).build()
    
    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button_handler))
    logger.info("‚úÖ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã")

    # –ó–∞–¥–∞—á–∏ JobQueue
    if application.job_queue:
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
        application.job_queue.run_repeating(
            lambda context: update_crypto_prices(),
            interval=300,
            name="crypto_update"
        )
        logger.info("üìä –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç")
        
        # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫—ç—à–∞ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
        application.job_queue.run_repeating(
            lambda context: save_cache_to_file(),
            interval=600,
            name="cache_save"
        )
        logger.info("üíæ –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫—ç—à–∞ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç")


    logger.info("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω! –û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π...")
    
    # –ó–∞–ø—É—Å–∫ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
    max_retries = 5
    retry_delay = 30  # –£–≤–µ–ª–∏—á–µ–Ω–∞ –Ω–∞—á–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è Render
    
    for attempt in range(max_retries):
        try:
            logger.info(f"üîÑ –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–ø—É—Å–∫–∞ {attempt+1}/{max_retries}")
            application.run_polling(
                drop_pending_updates=True,
                allowed_updates=Update.ALL_TYPES,
                poll_interval=2.0,  # –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
                close_loop=False,
                timeout=30
            )
            logger.info("‚úÖ –ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω")
            break
        except Conflict as e:
            logger.error(f"‚ö†Ô∏è –ö–æ–Ω—Ñ–ª–∏–∫—Ç (–ø–æ–ø—ã—Ç–∫–∞ {attempt+1}/{max_retries}): {e}")
            if attempt < max_retries - 1:
                logger.info(f"‚è≥ –ü–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ {retry_delay} —Å–µ–∫—É–Ω–¥...")
                time.sleep(retry_delay)
                retry_delay = min(retry_delay * 2, 300)  # –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ —Å –º–∞–∫—Å–∏–º—É–º–æ–º 5 –º–∏–Ω—É—Ç
            else:
                logger.error("‚ùå –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –ø–æ–≤—Ç–æ—Ä–æ–≤. –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
        except Exception as e:
            logger.error(f"‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
            if attempt < max_retries - 1:
                logger.info(f"‚è≥ –ü–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ {retry_delay} —Å–µ–∫—É–Ω–¥...")
                time.sleep(retry_delay)
            break

if __name__ == "__main__":
    main()
